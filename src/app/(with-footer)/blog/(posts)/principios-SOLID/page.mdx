import { localFormatDate } from "~/helpers/local-format-date"
import { ArticleHeader } from "~/components/ArticleHeader"

export const metadata = {
	title: "Principios SOLID: Fundamentos para un C贸digo Limpio y Mantenible",
	description:
		"Los Principios SOLID son un conjunto de cinco reglas de dise帽o de software que promueven la escritura de c贸digo limpio, flexible y f谩cil de mantener.",
	publishedOn: "July 2, 2023",
	lastModified: "July 2, 2023",
	emoji: "",
}

<ArticleHeader title={metadata.title} date={metadata.publishedOn} gradient="" />

Los Principios SOLID son un conjunto de cinco reglas de dise帽o de software que promueven la escritura de c贸digo limpio, flexible y f谩cil de mantener. Estos principios fueron propuestos por el ingeniero de software Robert C. Martin (tambi茅n conocido como "Uncle Bob") y se han convertido en una gu铆a invaluable para los desarrolladores que buscan mejorar la calidad de su c贸digo y el dise帽o de sus aplicaciones.

## Principio de Responsabilidad nica (Single Responsibility Principle - SRP)

El SRP establece que una clase debe tener una 煤nica responsabilidad y que esta responsabilidad debe estar encapsulada dentro de esa clase. En otras palabras, una clase debe tener una sola raz贸n para cambiar. Esto mejora la modularidad y evita que una clase se vuelva demasiado compleja y dif铆cil de mantener.

```js
// Mal: Una clase con m煤ltiples responsabilidades
class Usuario {
	obtenerDatosDeUsuario() {
		// L贸gica para obtener los datos de usuario desde el servidor
	}

	guardarDatosDeUsuario(datos) {
		// L贸gica para guardar los datos de usuario en el servidor
	}

	generarInformeDeUsuario() {
		// L贸gica para generar un informe del usuario
	}
}

// Bien: Clases con una 煤nica responsabilidad
class Usuario {
	obtenerDatosDeUsuario() {
		// L贸gica para obtener los datos de usuario desde el servidor
	}

	guardarDatosDeUsuario(datos) {
		// L贸gica para guardar los datos de usuario en el servidor
	}
}

class GeneradorInformeUsuario {
	generarInformeDeUsuario() {
		// L贸gica para generar un informe del usuario
	}
}
```

## Principio de Abierto/Cerrado (Open/Closed Principle - OCP)

El OCP establece que las entidades del software (clases, m贸dulos, etc.) deben estar abiertas para su extensi贸n pero cerradas para su modificaci贸n. En otras palabras, cuando se agregan nuevas funcionalidades o requisitos, se deben agregar nuevas clases o extensiones en lugar de modificar las clases existentes.

```js
// Mal: Modificar la clase existente para agregar una nueva funcionalidad
class Impresora {
	imprimirDocumento(documento) {
		// L贸gica para imprimir el documento
	}

	// Nueva funcionalidad requerida: imprimirDocumentoEnColor
	imprimirDocumentoEnColor(documento) {
		// L贸gica para imprimir el documento en color
	}
}

// Bien: Extender la clase para agregar la nueva funcionalidad
class Impresora {
	imprimirDocumento(documento) {
		// L贸gica para imprimir el documento
	}
}

class ImpresoraEnColor extends Impresora {
	imprimirDocumentoEnColor(documento) {
		// L贸gica para imprimir el documento en color
	}
}
```

## Principio de Sustituci贸n de Liskov (Liskov Substitution Principle - LSP)

El LSP establece que los objetos de una clase derivada deben poder sustituir a los objetos de la clase base sin afectar el comportamiento correcto del programa. En otras palabras, las clases derivadas deben ser totalmente sustituibles por sus clases base sin romper la funcionalidad.

```js
// Mal: Violaci贸n del LSP
class Ave {
	volar() {
		// L贸gica para volar
	}
}

class Pinguino extends Ave {
	volar() {
		// Los ping眉inos no pueden volar, entonces esto viola el LSP
	}
}

// Bien: Respeto del LSP
class Ave {
	volar() {
		// L贸gica para volar
	}
}

class Pinguino extends Ave {
	// Sin implementar el m茅todo volar, ya que los ping眉inos no pueden volar
}
```

## Principio de Segregaci贸n de Interfaces (Interface Segregation Principle - ISP)

El ISP establece que una clase no debe verse obligada a implementar interfaces que no utiliza. En lugar de tener una 煤nica interfaz grande, es mejor tener varias interfaces m谩s peque帽as y espec铆ficas para cada tipo de cliente.

```js
// Mal: Una 煤nica interfaz grande
interface Animal {
  caminar();
  nadar();
  volar();
}

class Pinguino implements Animal {
  caminar() {
    // L贸gica para caminar
  }

  nadar() {
    // L贸gica para nadar
  }

  // Los ping眉inos no pueden volar, entonces esto es innecesario
  volar() {}
}

// Bien: Interfaces segregadas
interface Caminante {
  caminar();
}

interface Nadador {
  nadar();
}

interface Volador {
  volar();
}

class Pinguino implements Caminante, Nadador {
  caminar() {
    // L贸gica para caminar
  }

  nadar() {
    // L贸gica para nadar
  }
}
```

## Principio de Inversi贸n de Dependencias (Dependency Inversion Principle - DIP)

El DIP establece que los m贸dulos de alto nivel no deben depender de m贸dulos de bajo nivel. Ambos deben depender de abstracciones. Adem谩s, las abstracciones no deben depender de los detalles; los detalles deben depender de las abstracciones.

```js
// Mal: Dependencia directa entre m贸dulos de alto y bajo nivel
class EmailSender {
  enviarEmail() {
    // L贸gica para enviar un email
  }
}

class UsuarioService {
  private emailSender: EmailSender;

  constructor() {
    this.emailSender = new EmailSender();
  }

  registrarUsuario() {
    // L贸gica para registrar un usuario y enviar un email de bienvenida
    this.emailSender.enviarEmail();
  }
}

// Bien: Dependencia inversa a trav茅s de abstracciones
interface Mensajero {
  enviarMensaje();
}

class EmailSender implements Mensajero {
  enviarMensaje() {
    // L贸gica para enviar un email
  }
}

class UsuarioService {
  private mensajero: Mensajero;

  constructor(mensajero: Mensajero) {
    this.mensajero = mensajero;
  }

  registrarUsuario() {
    // L贸gica para registrar un usuario y enviar un mensaje de bienvenida
    this.mensajero.enviarMensaje();
  }
}
```

Estos Principios SOLID proporcionan una base s贸lida para desarrollar c贸digo limpio, coherente y mantenible. Al aplicar estos principios en tu desarrollo de software, podr谩s crear aplicaciones m谩s robustas y flexibles, lo que facilitar谩 la adici贸n de nuevas funcionalidades y la escalabilidad a medida que tu proyecto crece.

Recuerda que la pr谩ctica y la comprensi贸n profunda de estos principios te ayudar谩n a convertirte en un desarrollador m谩s efectivo y respetuoso con la calidad del c贸digo que produces.
